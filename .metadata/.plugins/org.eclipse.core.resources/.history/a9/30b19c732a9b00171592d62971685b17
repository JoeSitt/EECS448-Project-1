package scheduler;

import java.text.SimpleDateFormat;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class Time {
	
	private boolean[] timeSlots;
	
	private Time(int milHours, boolean onHour) {
		timeSlots = new boolean[48];
		
		int timeIndex = milHours * 2;
		
		if (onHour) {
			timeIndex++;
		}
		
		timeSlots[timeIndex] = true;
	}
	
	public static Time makeTime(int milHours, boolean onHour) {
		if (milHours < 0 || milHours > 23) {
			return null;
		}
		return new Time(milHours, onHour);
	}
	
	public boolean[] getTimeSlots() {
		return timeSlots;
	}
	
	/*
	 * Add supplied time to timeSlots.
	 * Returns false if time passed is invalid or already contained in slots.
	 */
	public boolean addTime(int milHours, boolean onHour) {
		
		if (milHours < 0 || milHours > 23) {
			return false;
		}
		
		int timeIndex = milHours * 2;
		if (onHour) {
			timeIndex++;
		}
		
		// check if time already exists
		if (timeSlots[timeIndex]) {
			return false;
		}
		
		timeSlots[timeIndex] = true;
		return true;
	}
	
	/*
	 * Returns whether or not timeFormat is a use-able representation of a time
	 * 
	 * WARNING: Set of allowed time formats is extensive.
	 * Consult http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html
	 */
	public static boolean isTimeFormatValid(String timeFormat) {
		try {
			new SimpleDateFormat(timeFormat);
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	/*
	 * Returns whether or not the time string passed is valid.
	 * A time string is considered valid if it follows the passed format and exists.
	 * Time format string is assumed to be valid (have already passed an
	 * isTimeFormatValid(...) check).
	 * 
	 * NOTE: Because of the specificity of the method, a check is not performed on the
	 * timeFormat string. If this had been done and false had been returned, it would 
	 * give a misleading result.
	 */
	public static boolean isTimeStringValid(String timeString, String timeFormat) {
		
		SimpleDateFormat format = new SimpleDateFormat(timeFormat);
		format.setLenient(false);
		
		// Attempt parsing of timeString
		try {
			format.parse(timeString);
		} catch(Exception e) {
			return false;
		}
		
		// time string must be valid
		return true;
	}
	
	/*
	 * Parse time from string. String is expected to follow passed time format.
	 * Method will return null if format is not followed or parsing is unsuccessful.
	 */
	public static Time parseTime(String timeString, String timeFormat) {
		
		// ensure first that format passed is valid, and then that timeString follows format
		if (!isTimeFormatValid(timeFormat)) {
			return null;
		}		
		if (!isTimeStringValid(timeString, timeFormat)) {
			return null;
		}
		
		SimpleDateFormat format = new SimpleDateFormat(timeFormat);
		format.setLenient(false);
		Date tempDate;
		
		// attempt parsing of timeString
		try {
			tempDate = format.parse(timeString);
		} catch(Exception e) {
			return null;
		}
		
		int hour = tempDate.getHours();
		boolean onHour = false;
		if (tempDate.getMinutes() == 0) {
			onHour = true;
		}
		
		return makeTime(hour, onHour);
	}
	
	public static void main(String[] args) {
		String input = "12:30AM";
		String timeFormat = "hh:mmaa";
		
		System.out.println(Time.isTimeFormatValid(timeFormat));
		
		System.out.println(Time.isTimeStringValid(input, timeFormat));
		
//		Time t1 = Time.parseTime(input, timeFormat);
//		
//		for (boolean b : t1.getTimeSlots()) {
//			System.out.println(b);
//		}
		
	}
}
