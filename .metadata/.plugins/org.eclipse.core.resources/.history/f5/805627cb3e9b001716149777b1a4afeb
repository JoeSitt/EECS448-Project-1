package scheduler;

import java.text.SimpleDateFormat;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class Time {
	
	private boolean[] timeSlots;
	
	public static String militaryTimeFormat = "HH:mm";
	public static String civilianTimeFormat = "hh:mmaa";
	
	public Time() {
		timeSlots = new boolean[48];
	}
	
	/*
	 * Add supplied time to timeSlots.
	 * Returns false if time passed is invalid or already contained in slots.
	 */
	public boolean addTime(int milHours, boolean onHour) {
		if (milHours < 0 || milHours > 23) {
			return false;
		}
		
		int timeIndex = milHours * 2;
		if (!onHour) {
			timeIndex++;
		}
		
		// check if time already exists
		if (timeSlots[timeIndex]) {
			return false;
		}
		
		timeSlots[timeIndex] = true;
		return true;
	}
	
	public static boolean isCivTimeStringValid(String civTimeString) {
		try {
			new SimpleDateFormat(civilianTimeFormat).parse(civTimeString);
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	public static boolean isMilTimeStringValid(String milTimeString) {
		try {
			new SimpleDateFormat(militaryTimeFormat).parse(milTimeString);
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	public boolean addTimeString(String timeString) {
		Date tempDate;
		int hour;
		boolean onHour;
		
		// Determine which format to parse for (return false on error)
		if (isCivTimeStringValid(timeString)) {
			try {
				tempDate = new SimpleDateFormat(civilianTimeFormat).parse(timeString);
			} catch (Exception e) {
				System.out.println("Civilian time parsing failed");
				return false;
			}
		} else if (isMilTimeStringValid(timeString)) {
			try {
				tempDate = new SimpleDateFormat(militaryTimeFormat).parse(timeString);
			} catch (Exception e) {
				System.out.println("Military time parsing failed");
				return false;
			}
		} else {
			System.out.println("Time format unrecognized");
			return false;
		}
		
		// Extract hour and minute info
		hour = tempDate.getHours();
		if (tempDate.getMinutes() == 0) {
			onHour = true;
		} else {
			onHour = false;
		}
		
		// Add time
		return addTime(hour, onHour);
	}
	
	public List<String> getTimeStrings(boolean useMil) {
		List<String> timeList = new ArrayList<String>();
		for (int i = 0; i < this.timeSlots.length; i++) {
			if (timeSlots[i]) {
				timeList.add(slotIndexToString(i, useMil));
			}
		}
		return timeList;
	}
	
	public static String slotIndexToString(int index, boolean useMil) {
		
		String timeFormat;
		
		if (useMil) {
			timeFormat = militaryTimeFormat;
		} else {
			timeFormat = civilianTimeFormat;
		}
		
		if (index < 0 || index > 47) {
			return "ERROR: invalid index passed to slotIndexToString(...)";
		}
		
		Date tempDate = new Date();
		tempDate.setHours(index / 2);
		if (index % 2 == 0) {
			tempDate.setMinutes(0);
		} else {
			tempDate.setMinutes(30);
		}
		
		return new SimpleDateFormat(timeFormat).format(tempDate);
	}
	
	public boolean[] getTimeSlots() {
		return timeSlots;
	}
	
//	/*
//	 * Returns whether or not timeFormat is a use-able representation of a time
//	 * 
//	 * WARNING: Set of allowed time formats is extensive.
//	 * Consult http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html
//	 */
//	public static boolean isTimeFormatValid(String timeFormat) {
//		try {
//			new SimpleDateFormat(timeFormat);
//		} catch(Exception e) {
//			return false;
//		}
//		return true;
//	}
//	
//	/*
//	 * Returns whether or not the time string passed is valid.
//	 * A time string is considered valid if it follows the passed format and exists.
//	 * Time format string is assumed to be valid (have already passed an
//	 * isTimeFormatValid(...) check).
//	 * 
//	 * NOTE: Because of the specificity of the method, a check is not performed on the
//	 * timeFormat string. If this had been done and false had been returned, it would 
//	 * give a misleading result.
//	 */
//	public static boolean isTimeStringValid(String timeString, String timeFormat) {
//		
//		SimpleDateFormat format = new SimpleDateFormat(timeFormat);
//		format.setLenient(false);
//		
//		// Attempt parsing of timeString
//		try {
//			format.parse(timeString);
//		} catch(Exception e) {
//			return false;
//		}
//		
//		// time string must be valid
//		return true;
//	}
//	
//	/*
//	 * Parse time from string. String is expected to follow passed time format.
//	 * Method will return null if format is not followed or parsing is unsuccessful.
//	 */
//	public static Time parseTime(String timeString, String timeFormat) {
//		
//		// ensure first that format passed is valid, and then that timeString follows format
//		if (!isTimeFormatValid(timeFormat)) {
//			return null;
//		}		
//		if (!isTimeStringValid(timeString, timeFormat)) {
//			return null;
//		}
//		
//		SimpleDateFormat format = new SimpleDateFormat(timeFormat);
//		format.setLenient(false);
//		Date tempDate;
//		
//		// attempt parsing of timeString
//		try {
//			tempDate = format.parse(timeString);
//		} catch(Exception e) {
//			return null;
//		}
//		
//		int hour = tempDate.getHours();
//		boolean onHour = false;
//		if (tempDate.getMinutes() == 0) {
//			onHour = true;
//		}
//		
//		return makeTime(hour, onHour);
//	}
	
	// TODO:
	// - Handle case where input is not on half-hour
	public static void main(String[] args) {
		String input = "12:49";
		boolean useMil = false;
		
		Time t = new Time();
		
		System.out.println(t.addTimeString(input));
		
		for (String timeString : t.getTimeStrings(useMil)) {
			System.out.println(timeString);
		}
		
	}
}
